# ä»»åŠ¡ 11ï¼šæˆ˜æ–—å›åˆæœºåˆ¶

## ğŸ“‹ ä»»åŠ¡ç›®æ ‡
å®ç°å›åˆåˆ¶æˆ˜æ–—çš„æ ¸å¿ƒæœºåˆ¶ï¼ŒåŒ…æ‹¬å›åˆæµç¨‹ã€è¡ŒåŠ¨é¡ºåºã€æˆ˜æ–—å¿«ç…§ã€‚

## ğŸ“ éœ€è¦åˆ›å»º/ä¿®æ”¹çš„æ–‡ä»¶

### åç«¯æ–‡ä»¶
```
backend/internal/battle/
â”œâ”€â”€ engine.go           # æˆ˜æ–—å¼•æ“
â”œâ”€â”€ round.go            # å›åˆå¤„ç†
â”œâ”€â”€ snapshot.go         # æˆ˜æ–—å¿«ç…§
â”œâ”€â”€ damage.go           # ä¼¤å®³è®¡ç®—
â””â”€â”€ wave.go             # æ³¢æ¬¡ç®¡ç†

backend/internal/model/
â”œâ”€â”€ battle_state.go     # æˆ˜æ–—çŠ¶æ€æ¨¡å‹
â””â”€â”€ battle_unit.go      # æˆ˜æ–—å•ä½æ¨¡å‹
```

## ğŸ“ è¯¦ç»†å®ç°è¦æ±‚

### 1. æˆ˜æ–—å•ä½æ¨¡å‹ (BattleUnit)
```go
type BattleUnitType string

const (
    UnitTypePlayer BattleUnitType = "player"
    UnitTypeEnemy  BattleUnitType = "enemy"
)

type BattleUnit struct {
    ID           string         `json:"id"`         // å”¯ä¸€æ ‡è¯†
    Type         BattleUnitType `json:"type"`
    Name         string         `json:"name"`
    
    // åŸå§‹å¼•ç”¨
    CharacterID  *uint          `json:"character_id,omitempty"`
    EnemyID      *uint          `json:"enemy_id,omitempty"`
    
    // æˆ˜æ–—å±æ€§ï¼ˆå¿«ç…§ï¼‰- åŸºäºæ–¹æ¡ˆBå±æ€§è®¾è®¡
    MaxHP        int            `json:"max_hp"`       // ç”Ÿå‘½å€¼ä¸Šé™ï¼ˆæ¥è‡ªè€åŠ›ï¼‰
    CurrentHP    int            `json:"current_hp"`   // å½“å‰ç”Ÿå‘½å€¼
    MaxMP        int            `json:"max_mp"`       // é­”æ³•å€¼ä¸Šé™ï¼ˆæ¥è‡ªæ™ºåŠ›ï¼‰
    CurrentMP    int            `json:"current_mp"`   // å½“å‰é­”æ³•å€¼
    
    // æ”»å‡»å±æ€§
    PhysicalAtk  int            `json:"physical_atk"` // ç‰©ç†æ”»å‡»ï¼ˆæ¥è‡ªåŠ›é‡ï¼‰
    MagicAtk     int            `json:"magic_atk"`    // é­”æ³•æ”»å‡»ï¼ˆæ¥è‡ªæ™ºåŠ›ï¼‰
    
    // é˜²å¾¡å±æ€§
    PhysicalDef  int            `json:"physical_def"` // ç‰©ç†é˜²å¾¡ï¼ˆæ¥è‡ªè€åŠ›ï¼‰
    MagicDef     int            `json:"magic_def"`    // é­”æ³•é˜²å¾¡ï¼ˆæ¥è‡ªæ™ºåŠ›ï¼‰
    
    // å…¶ä»–æˆ˜æ–—å±æ€§
    Speed        int            `json:"speed"`        // é€Ÿåº¦ï¼ˆæ¥è‡ªæ•æ·ï¼‰
    DodgeRate    float64        `json:"dodge_rate"`   // é—ªé¿ç‡ï¼ˆæ¥è‡ªæ•æ·ï¼‰
    CritRate     float64        `json:"crit_rate"`    // æš´å‡»ç‡ï¼ˆæ¥è‡ªå¹¸è¿ï¼‰
    CritDamage   float64        `json:"crit_damage"`  // æš´å‡»ä¼¤å®³ï¼ˆæ¥è‡ªå¹¸è¿ï¼‰
    
    // çŠ¶æ€
    IsAlive      bool           `json:"is_alive"`
    Buffs        []BuffInstance `json:"buffs"`
    Debuffs      []BuffInstance `json:"debuffs"`
    
    // æŠ€èƒ½é…ç½®ï¼ˆå¿«ç…§ï¼‰
    Skills       []SkillConfig  `json:"skills"`
}

// å±æ€§è®¡ç®—å…¬å¼ï¼ˆä»åŸºç¡€å±æ€§è®¡ç®—è¡ç”Ÿå±æ€§ï¼‰
// MaxHP = 100 + è€åŠ› * 10
// MaxMP = 50 + æ™ºåŠ› * 5
// PhysicalAtk = åŠ›é‡ * 2 + è£…å¤‡åŠ æˆ
// MagicAtk = æ™ºåŠ› * 2 + è£…å¤‡åŠ æˆ
// PhysicalDef = è€åŠ› * 1.5 + è£…å¤‡åŠ æˆ
// MagicDef = æ™ºåŠ› * 1 + è£…å¤‡åŠ æˆ
// Speed = æ•æ· * 1 + è£…å¤‡åŠ æˆ
// DodgeRate = æ•æ· * 0.2% + è£…å¤‡åŠ æˆ
// CritRate = å¹¸è¿ * 0.1% + è£…å¤‡åŠ æˆ
// CritDamage = 1.5 + å¹¸è¿ * 0.5% + è£…å¤‡åŠ æˆ
```

### 2. æˆ˜æ–—çŠ¶æ€æ¨¡å‹ (BattleState)
```go
type BattlePhase string

const (
    PhasePreparation BattlePhase = "preparation"  // å¤‡æˆ˜é˜¶æ®µ
    PhaseAction      BattlePhase = "action"       // è¡ŒåŠ¨é˜¶æ®µ
    PhaseSettlement  BattlePhase = "settlement"   // ç»“ç®—é˜¶æ®µ
)

type BattleState struct {
    RoomID       string        `json:"room_id"`
    ZoneCode     string        `json:"zone_code"`
    WaveNumber   int           `json:"wave_number"`
    RoundNumber  int           `json:"round_number"`
    Phase        BattlePhase   `json:"phase"`
    
    Players      []BattleUnit  `json:"players"`
    Enemies      []BattleUnit  `json:"enemies"`
    
    ActionQueue  []string      `json:"action_queue"`  // è¡ŒåŠ¨é¡ºåºï¼ˆå•ä½IDåˆ—è¡¨ï¼‰
    CurrentUnit  string        `json:"current_unit"`  // å½“å‰è¡ŒåŠ¨å•ä½
    
    AutoRestart  bool          `json:"auto_restart"`  // å…¨å‘˜æ­»äº¡åè‡ªåŠ¨é‡å¼€
    IsFinished   bool          `json:"is_finished"`
}
```

### 3. æˆ˜æ–—å¿«ç…§æœºåˆ¶
```go
type BattleSnapshot struct {
    CharacterID uint      `json:"character_id"`
    TakenAt     time.Time `json:"taken_at"`
    
    // å±æ€§å¿«ç…§
    Stats       UnitStats `json:"stats"`
    
    // è£…å¤‡å¿«ç…§
    Equipment   []EquipmentSnapshot `json:"equipment"`
    
    // æŠ€èƒ½é…ç½®å¿«ç…§
    Skills      []SkillConfig `json:"skills"`
}

// TakeSnapshot æˆ˜æ–—å¼€å§‹æ—¶åˆ›å»ºå¿«ç…§
func TakeSnapshot(characterID uint) (*BattleSnapshot, error) {
    // 1. è·å–è§’è‰²åŸºç¡€å±æ€§
    // 2. è·å–è£…å¤‡åŠ æˆ
    // 3. è·å–æŠ€èƒ½é…ç½®
    // 4. è®¡ç®—æœ€ç»ˆå±æ€§
    // 5. è¿”å›å¿«ç…§
}
```

### 4. å›åˆæµç¨‹
```go
type RoundProcessor struct {
    state *BattleState
}

// ProcessRound å¤„ç†ä¸€ä¸ªå®Œæ•´å›åˆ
func (p *RoundProcessor) ProcessRound() []BattleEvent {
    events := []BattleEvent{}
    
    // 1. å¤‡æˆ˜é˜¶æ®µ
    events = append(events, p.processPreparation()...)
    
    // 2. è¡ŒåŠ¨é˜¶æ®µ
    events = append(events, p.processActions()...)
    
    // 3. ç»“ç®—é˜¶æ®µ
    events = append(events, p.processSettlement()...)
    
    return events
}

// processPreparation å¤‡æˆ˜é˜¶æ®µ
func (p *RoundProcessor) processPreparation() []BattleEvent {
    events := []BattleEvent{}
    
    // 1. è§¦å‘å›åˆå¼€å§‹è£…å¤‡æ•ˆæœ
    // 2. è§¦å‘è¢«åŠ¨æŠ€èƒ½
    // 3. ç»“ç®— Buff/Debuff å›åˆæ•°
    // 4. ç»“ç®—æŒç»­ä¼¤å®³/æ²»ç–—
    
    return events
}

// processActions è¡ŒåŠ¨é˜¶æ®µ
func (p *RoundProcessor) processActions() []BattleEvent {
    events := []BattleEvent{}
    
    // 1. æŒ‰é€Ÿåº¦æ’åºç”Ÿæˆè¡ŒåŠ¨é˜Ÿåˆ—
    p.state.ActionQueue = p.generateActionQueue()
    
    // 2. ä¾æ¬¡æ‰§è¡Œæ¯ä¸ªå•ä½çš„è¡ŒåŠ¨
    for _, unitID := range p.state.ActionQueue {
        unit := p.getUnit(unitID)
        if !unit.IsAlive {
            continue
        }
        
        action := p.determineAction(unit)
        result := p.executeAction(unit, action)
        events = append(events, result.Events...)
        
        // æ£€æŸ¥æˆ˜æ–—æ˜¯å¦ç»“æŸ
        if p.checkBattleEnd() {
            break
        }
    }
    
    return events
}

// processSettlement ç»“ç®—é˜¶æ®µ
func (p *RoundProcessor) processSettlement() []BattleEvent {
    events := []BattleEvent{}
    
    // 1. è§¦å‘å›åˆç»“æŸæ•ˆæœ
    // 2. åˆ¤æ–­èƒœè´Ÿ
    // 3. å¦‚æœæ•Œäººå…¨ç­ï¼Œè¿›å…¥ä¸‹ä¸€æ³¢
    
    return events
}
```

### 5. è¡ŒåŠ¨é˜Ÿåˆ—ç”Ÿæˆ
```go
// generateActionQueue æŒ‰é€Ÿåº¦ç”Ÿæˆè¡ŒåŠ¨é¡ºåº
func (p *RoundProcessor) generateActionQueue() []string {
    allUnits := append(p.state.Players, p.state.Enemies...)
    
    // è¿‡æ»¤å­˜æ´»å•ä½
    alive := []BattleUnit{}
    for _, u := range allUnits {
        if u.IsAlive {
            alive = append(alive, u)
        }
    }
    
    // æŒ‰é€Ÿåº¦æ’åºï¼ˆé€Ÿåº¦ç›¸åŒæ—¶éšæœºï¼‰
    sort.SliceStable(alive, func(i, j int) bool {
        if alive[i].Speed == alive[j].Speed {
            return rand.Float32() < 0.5
        }
        return alive[i].Speed > alive[j].Speed
    })
    
    queue := make([]string, len(alive))
    for i, u := range alive {
        queue[i] = u.ID
    }
    return queue
}
```

### 6. ä¼¤å®³è®¡ç®—ï¼ˆæ–¹æ¡ˆB - åŒºåˆ†ç‰©ç†/é­”æ³•ï¼‰
```go
type DamageType string

const (
    DamageTypePhysical DamageType = "physical"  // ç‰©ç†ä¼¤å®³
    DamageTypeMagic    DamageType = "magic"     // é­”æ³•ä¼¤å®³
)

type DamageResult struct {
    DamageType   DamageType `json:"damage_type"`
    BaseDamage   int        `json:"base_damage"`
    FinalDamage  int        `json:"final_damage"`
    IsCrit       bool       `json:"is_crit"`
    IsDodged     bool       `json:"is_dodged"`   // æ˜¯å¦è¢«é—ªé¿
}

// CalculateDamage è®¡ç®—ä¼¤å®³ï¼ˆæ”¯æŒç‰©ç†/é­”æ³•ä¸¤ç§ç±»å‹ï¼‰
func CalculateDamage(attacker, defender *BattleUnit, skillPower float64, damageType DamageType) DamageResult {
    result := DamageResult{DamageType: damageType}
    
    // 1. é—ªé¿åˆ¤å®šï¼ˆä»…ç‰©ç†æ”»å‡»å¯è¢«é—ªé¿ï¼‰
    if damageType == DamageTypePhysical {
        if rand.Float64() < defender.DodgeRate {
            result.IsDodged = true
            result.FinalDamage = 0
            return result
        }
    }
    
    // 2. è®¡ç®—åŸºç¡€ä¼¤å®³
    var baseDamage float64
    var defense int
    
    switch damageType {
    case DamageTypePhysical:
        baseDamage = float64(attacker.PhysicalAtk) * skillPower
        defense = defender.PhysicalDef
    case DamageTypeMagic:
        baseDamage = float64(attacker.MagicAtk) * skillPower
        defense = defender.MagicDef
    }
    result.BaseDamage = int(baseDamage)
    
    // 3. é˜²å¾¡å‡ä¼¤ = é˜²å¾¡ / (é˜²å¾¡ + 100)
    defenseReduction := float64(defense) / (float64(defense) + 100)
    
    // 4. æš´å‡»åˆ¤å®šï¼ˆæ¥è‡ªå¹¸è¿ï¼‰
    critMultiplier := 1.0
    if rand.Float64() < attacker.CritRate {
        result.IsCrit = true
        critMultiplier = attacker.CritDamage
    }
    
    // 5. æœ€ç»ˆä¼¤å®³
    result.FinalDamage = int(baseDamage * (1 - defenseReduction) * critMultiplier)
    
    return result
}

// ç¤ºä¾‹ï¼šç‰©ç†æŠ€èƒ½è°ƒç”¨
// result := CalculateDamage(attacker, defender, 1.5, DamageTypePhysical)

// ç¤ºä¾‹ï¼šé­”æ³•æŠ€èƒ½è°ƒç”¨
// result := CalculateDamage(attacker, defender, 2.0, DamageTypeMagic)
```

### 7. æ³¢æ¬¡ç®¡ç†
```go
// NextWave è¿›å…¥ä¸‹ä¸€æ³¢
func (p *RoundProcessor) NextWave() {
    p.state.WaveNumber++
    p.state.RoundNumber = 0
    
    // ç”Ÿæˆæ–°æ•Œäºº
    enemies := p.generateEnemies()
    p.state.Enemies = enemies
    
    // æ£€æŸ¥æ˜¯å¦å‡ºç° Boss
    if p.state.WaveNumber % p.getBossInterval() == 0 {
        boss := p.generateBoss()
        p.state.Enemies = append(p.state.Enemies, boss)
    }
}
```

## âœ… éªŒè¯æ£€æŸ¥ç‚¹

å®Œæˆåè¯·éªŒè¯ï¼š
1. [ ] æˆ˜æ–—å¼€å§‹æ—¶æ­£ç¡®åˆ›å»ºå¿«ç…§ï¼ˆåŒ…å«æ‰€æœ‰æ–¹æ¡ˆBå±æ€§ï¼‰
2. [ ] å›åˆä¸‰é˜¶æ®µæ­£ç¡®æ‰§è¡Œ
3. [ ] è¡ŒåŠ¨é¡ºåºæŒ‰é€Ÿåº¦ï¼ˆæ•æ·ï¼‰æ’åº
4. [ ] ç‰©ç†ä¼¤å®³ä½¿ç”¨ PhysicalAtk å’Œ PhysicalDef
5. [ ] é­”æ³•ä¼¤å®³ä½¿ç”¨ MagicAtk å’Œ MagicDef
6. [ ] é—ªé¿åˆ¤å®šæ­£ç¡®ï¼ˆä»…ç‰©ç†æ”»å‡»å¯è¢«é—ªé¿ï¼‰
7. [ ] æš´å‡»ç‡å’Œæš´å‡»ä¼¤å®³ï¼ˆæ¥è‡ªå¹¸è¿ï¼‰æ­£ç¡®
8. [ ] é˜²å¾¡å‡ä¼¤å…¬å¼æ­£ç¡®
9. [ ] å•ä½æ­»äº¡åä¸å†è¡ŒåŠ¨
10. [ ] æ•Œäººå…¨ç­åè¿›å…¥ä¸‹ä¸€æ³¢
11. [ ] Boss æŒ‰é—´éš”å‡ºç°

## ğŸ”— ä¾èµ–å…³ç³»
- ä¾èµ–ï¼šä»»åŠ¡ 08ï¼ˆè£…å¤‡ç³»ç»Ÿï¼Œç”¨äºå¿«ç…§ï¼‰
- ä¾èµ–ï¼šä»»åŠ¡ 10ï¼ˆæˆ˜æ–—åŸºç¡€æ¶æ„ï¼‰
