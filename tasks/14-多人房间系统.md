# ä»»åŠ¡ 14ï¼šå¤šäººæˆ¿é—´ç³»ç»Ÿ

## ğŸ“‹ ä»»åŠ¡ç›®æ ‡
å®ç°å¤šäººæˆ˜æ–—æˆ¿é—´ç³»ç»Ÿï¼Œæ”¯æŒ 1-3 äººç»„é˜Ÿæˆ˜æ–—ï¼Œç¦»çº¿å¤„ç†ï¼Œç‹¬ç«‹æ‰è½ã€‚

## ğŸ“ éœ€è¦åˆ›å»º/ä¿®æ”¹çš„æ–‡ä»¶

### åç«¯æ–‡ä»¶
```
backend/internal/model/
â””â”€â”€ battle_room.go      # æˆ¿é—´æ¨¡å‹

backend/internal/battle/
â”œâ”€â”€ room_manager.go     # æˆ¿é—´ç®¡ç†å™¨
â”œâ”€â”€ room.go             # æˆ¿é—´å®ä¾‹
â””â”€â”€ loot.go             # æ‰è½å¤„ç†

backend/internal/websocket/
â””â”€â”€ room_handler.go     # æˆ¿é—´ WebSocket å¤„ç†
```

### å‰ç«¯æ–‡ä»¶
```
frontend/src/
â”œâ”€â”€ views/
â”‚   â”œâ”€â”€ RoomList.vue    # æˆ¿é—´åˆ—è¡¨
â”‚   â””â”€â”€ BattleRoom.vue  # æˆ˜æ–—æˆ¿é—´
â””â”€â”€ components/
    â”œâ”€â”€ CreateRoom.vue  # åˆ›å»ºæˆ¿é—´å¯¹è¯æ¡†
    â””â”€â”€ PlayerList.vue  # æˆ¿é—´ç©å®¶åˆ—è¡¨
```

## ğŸ“ è¯¦ç»†å®ç°è¦æ±‚

### 1. æˆ¿é—´æ¨¡å‹
```go
type RoomStatus string

const (
    RoomStatusWaiting   RoomStatus = "waiting"    // ç­‰å¾…ä¸­
    RoomStatusBattling  RoomStatus = "battling"   // æˆ˜æ–—ä¸­
    RoomStatusFinished  RoomStatus = "finished"   // å·²ç»“æŸ
)

type BattleRoom struct {
    ID          string       `json:"id"`           // æˆ¿é—´ID
    Name        string       `json:"name"`         // æˆ¿é—´åç§°
    ZoneCode    string       `json:"zone_code"`    // æˆ˜æ–—åŒºåŸŸ
    OwnerID     uint         `json:"owner_id"`     // æˆ¿ä¸»è§’è‰²ID
    MaxPlayers  int          `json:"max_players"`  // æœ€å¤§äººæ•° 1-3
    AutoRestart bool         `json:"auto_restart"` // è‡ªåŠ¨é‡å¼€
    Status      RoomStatus   `json:"status"`
    
    Players     []RoomPlayer `json:"players"`
    
    CreatedAt   time.Time    `json:"created_at"`
}

type RoomPlayer struct {
    CharacterID uint   `json:"character_id"`
    Name        string `json:"name"`
    IsOnline    bool   `json:"is_online"`
    IsReady     bool   `json:"is_ready"`
}
```

### 2. æˆ¿é—´ç®¡ç†å™¨
```go
type RoomManager struct {
    rooms   map[string]*BattleRoom
    players map[uint]string  // characterID -> roomID
    mu      sync.RWMutex
}

// CreateRoom åˆ›å»ºæˆ¿é—´
func (rm *RoomManager) CreateRoom(ownerID uint, config RoomConfig) (*BattleRoom, error) {
    rm.mu.Lock()
    defer rm.mu.Unlock()
    
    // æ£€æŸ¥ç©å®¶æ˜¯å¦å·²åœ¨æˆ¿é—´ä¸­
    if _, exists := rm.players[ownerID]; exists {
        return nil, errors.New("already in a room")
    }
    
    room := &BattleRoom{
        ID:          generateRoomID(),
        Name:        config.Name,
        ZoneCode:    config.ZoneCode,
        OwnerID:     ownerID,
        MaxPlayers:  config.MaxPlayers,
        AutoRestart: config.AutoRestart,
        Status:      RoomStatusWaiting,
        Players: []RoomPlayer{{
            CharacterID: ownerID,
            IsOnline:    true,
            IsReady:     false,
        }},
        CreatedAt: time.Now(),
    }
    
    rm.rooms[room.ID] = room
    rm.players[ownerID] = room.ID
    
    return room, nil
}

// JoinRoom åŠ å…¥æˆ¿é—´
func (rm *RoomManager) JoinRoom(characterID uint, roomID string) error {
    rm.mu.Lock()
    defer rm.mu.Unlock()
    
    room, exists := rm.rooms[roomID]
    if !exists {
        return errors.New("room not found")
    }
    
    if len(room.Players) >= room.MaxPlayers {
        return errors.New("room is full")
    }
    
    if room.Status != RoomStatusWaiting {
        return errors.New("room is not waiting")
    }
    
    room.Players = append(room.Players, RoomPlayer{
        CharacterID: characterID,
        IsOnline:    true,
        IsReady:     false,
    })
    
    rm.players[characterID] = roomID
    
    return nil
}

// LeaveRoom ç¦»å¼€æˆ¿é—´
func (rm *RoomManager) LeaveRoom(characterID uint) error

// GetPublicRooms è·å–å…¬å¼€æˆ¿é—´åˆ—è¡¨
func (rm *RoomManager) GetPublicRooms(zoneCode string) []BattleRoom

// StartBattle å¼€å§‹æˆ˜æ–—
func (rm *RoomManager) StartBattle(roomID string) error
```

### 3. ç¦»çº¿å¤„ç†é€»è¾‘
```go
// HandleDisconnect å¤„ç†ç©å®¶æ–­çº¿
func (rm *RoomManager) HandleDisconnect(characterID uint) {
    roomID, exists := rm.players[characterID]
    if !exists {
        return
    }
    
    room := rm.rooms[roomID]
    
    // æ ‡è®°ä¸ºç¦»çº¿
    for i := range room.Players {
        if room.Players[i].CharacterID == characterID {
            room.Players[i].IsOnline = false
            break
        }
    }
    
    // å¦‚æœæ˜¯æˆ˜æ–—ä¸­ï¼Œè§’è‰²ç»§ç»­å‚ä¸å½“å‰æ³¢æ¬¡
    // ä¸‹ä¸€æ³¢å¼€å§‹æ—¶ç§»é™¤ç¦»çº¿ç©å®¶
    if room.Status == RoomStatusBattling {
        room.BattleState.MarkPlayerOffline(characterID)
    }
}

// HandleReconnect å¤„ç†ç©å®¶é‡è¿
func (rm *RoomManager) HandleReconnect(characterID uint, client *Client) {
    roomID, exists := rm.players[characterID]
    if !exists {
        return
    }
    
    room := rm.rooms[roomID]
    
    // æ ‡è®°ä¸ºåœ¨çº¿
    for i := range room.Players {
        if room.Players[i].CharacterID == characterID {
            room.Players[i].IsOnline = true
            break
        }
    }
    
    // å‘é€å½“å‰æˆ˜æ–—çŠ¶æ€
    if room.Status == RoomStatusBattling {
        client.Send(MsgTypeBattleState, room.BattleState)
    }
}
```

### 4. ç‹¬ç«‹æ‰è½ç³»ç»Ÿ
```go
type LootManager struct{}

// GenerateLoot ä¸ºæ¯ä¸ªç©å®¶ç”Ÿæˆç‹¬ç«‹æ‰è½
func (lm *LootManager) GenerateLoot(players []BattleUnit, enemies []Enemy) map[uint][]LootItem {
    result := make(map[uint][]LootItem)
    
    for _, player := range players {
        if player.CharacterID == nil {
            continue
        }
        
        charID := *player.CharacterID
        character := getCharacter(charID)
        
        // è·å–è§’è‰²æˆ˜åˆ©å“æ‰è½ç‡åŠ æˆ
        lootBonus := character.LootDropRate
        
        for _, enemy := range enemies {
            lootConfig := parseEnemyLoot(enemy.LootConfig)
            
            for _, loot := range lootConfig {
                // åº”ç”¨æ‰è½ç‡åŠ æˆ
                adjustedChance := loot.Chance * (1 + lootBonus)
                
                if rand.Float64() < adjustedChance {
                    result[charID] = append(result[charID], LootItem{
                        ItemCode: loot.ItemCode,
                        Quantity: loot.Quantity,
                    })
                }
            }
        }
    }
    
    return result
}

// DistributeLoot åˆ†å‘æ‰è½åˆ°å„ç©å®¶ä»“åº“
func (lm *LootManager) DistributeLoot(loot map[uint][]LootItem) error {
    for charID, items := range loot {
        for _, item := range items {
            addToInventory(charID, item.ItemCode, item.Quantity)
        }
    }
    return nil
}
```

### 5. æ³¢æ¬¡åˆ‡æ¢å¤„ç†
```go
// OnWaveComplete æ³¢æ¬¡å®Œæˆæ—¶
func (room *BattleRoom) OnWaveComplete() {
    // 1. ç”Ÿæˆå¹¶åˆ†å‘æ‰è½
    loot := room.LootManager.GenerateLoot(room.BattleState.Players, room.BattleState.Enemies)
    room.LootManager.DistributeLoot(loot)
    
    // 2. å¹¿æ’­æ‰è½ä¿¡æ¯
    room.BroadcastToPlayers(MsgTypeLoot, loot)
    
    // 3. ç§»é™¤ç¦»çº¿ç©å®¶
    room.removeOfflinePlayers()
    
    // 4. æ£€æŸ¥æ˜¯å¦è¿˜æœ‰ç©å®¶
    if len(room.OnlinePlayers()) == 0 {
        room.End()
        return
    }
    
    // 5. è¿›å…¥ä¸‹ä¸€æ³¢
    room.BattleState.NextWave()
}

// removeOfflinePlayers ç§»é™¤ç¦»çº¿ç©å®¶
func (room *BattleRoom) removeOfflinePlayers() {
    onlinePlayers := []BattleUnit{}
    for _, player := range room.BattleState.Players {
        if player.CharacterID == nil {
            continue
        }
        if room.isPlayerOnline(*player.CharacterID) {
            onlinePlayers = append(onlinePlayers, player)
        }
    }
    room.BattleState.Players = onlinePlayers
}
```

### 6. WebSocket æ¶ˆæ¯å¤„ç†
```go
// æˆ¿é—´ç›¸å…³æ¶ˆæ¯
type CreateRoomPayload struct {
    Name        string `json:"name"`
    ZoneCode    string `json:"zone_code"`
    MaxPlayers  int    `json:"max_players"`
    AutoRestart bool   `json:"auto_restart"`
}

type JoinRoomPayload struct {
    RoomID string `json:"room_id"`
}

type RoomStatePayload struct {
    Room    BattleRoom `json:"room"`
    Players []RoomPlayer `json:"players"`
}
```

### 7. API æ¥å£
| æ–¹æ³• | è·¯å¾„ | è¯´æ˜ |
|------|------|------|
| GET | /api/rooms | è·å–å…¬å¼€æˆ¿é—´åˆ—è¡¨ |
| POST | /api/rooms | åˆ›å»ºæˆ¿é—´ |
| POST | /api/rooms/:id/join | åŠ å…¥æˆ¿é—´ |
| POST | /api/rooms/:id/leave | ç¦»å¼€æˆ¿é—´ |
| POST | /api/rooms/:id/ready | å‡†å¤‡ |
| POST | /api/rooms/:id/start | å¼€å§‹æˆ˜æ–—ï¼ˆæˆ¿ä¸»ï¼‰ |

## âœ… éªŒè¯æ£€æŸ¥ç‚¹

å®Œæˆåè¯·éªŒè¯ï¼š
1. [ ] èƒ½åˆ›å»ºæˆ¿é—´å¹¶åœ¨åˆ—è¡¨æ˜¾ç¤º
2. [ ] å…¶ä»–ç©å®¶èƒ½åŠ å…¥æˆ¿é—´
3. [ ] æˆ¿é—´äººæ•°é™åˆ¶ç”Ÿæ•ˆ
4. [ ] æˆ˜æ–—ä¸­ç¦»çº¿è§’è‰²ç»§ç»­å‚ä¸å½“å‰æ³¢æ¬¡
5. [ ] ä¸‹ä¸€æ³¢æ­£ç¡®ç§»é™¤ç¦»çº¿ç©å®¶
6. [ ] æ¯ä¸ªç©å®¶ç‹¬ç«‹ç”Ÿæˆæ‰è½
7. [ ] æˆ˜åˆ©å“æ‰è½ç‡åŠ æˆç”Ÿæ•ˆ
8. [ ] æ–­çº¿é‡è¿åæ­£ç¡®æ¢å¤æˆ˜æ–—çŠ¶æ€

## ğŸ”— ä¾èµ–å…³ç³»
- ä¾èµ–ï¼šä»»åŠ¡ 10ï¼ˆæˆ˜æ–—åŸºç¡€æ¶æ„ï¼ŒWebSocketï¼‰
- ä¾èµ–ï¼šä»»åŠ¡ 11ï¼ˆæˆ˜æ–—å›åˆæœºåˆ¶ï¼‰
